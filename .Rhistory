dpu %>%
select('log_date', 'user_id', 'payment'),
by = c('log_date', 'user_id')
) %>%
mutate(is.payment = ifelse(is.na(payment), 0, 1)) %>%
mutate(payment = ifelse(is.na(payment), 0, payment)) -> dau_1
dau_1 %>%
mutate(log_year = lubridate::year(log_date) %>% as.character(),
log_month = lubridate::month(log_date) %>% as.character(),
log_day = lubridate::day(log_date) %>% as.character()) %>%
mutate(log_month = paste(log_year, log_month, sep  = '-')) %>%
group_by(log_month, user_id) %>%
summarise(sum.payment = sum(payment),
access_days = n()) -> mau
mau
library(ykmeans)
library(scales)
action <- as.data.frame(action)
# A47 항목이 랭킹 포인트를 의미합니다.
# variable name도 A47, target name도 A47로 합니다...
user.action2 <- ykmeans(action, 'A47', 'A47', 3)
user.action2$cluster %>% table()
user.action2$cluster %>% table() %>%
enframe() %>%
mutate(total_n = sum(value)) %>%
mutate(pct.value = value / total_n * 100) %>%
ggplot(aes(name, pct.value)) + geom_bar(stat = 'identity') +
xlab('Cluster') +
ylab('Percent of counts')
user.action2 %>%
arrange(desc(A47)) %>%
ggplot(aes(1:length(user_id), y = A47)) +
geom_line() +
xlab('User') +
ylab('Ranking Point(A47)') +
scale_y_continuous(label = comma)
user.action2 %>%
ggplot(aes(A47)) + geom_histogram()
user.action2 %>%
filter(cluster %in% c(2, 3)) -> user.action.h
user.action.h %>% head()
library(caret)
# 유저 행위에 대한 데이터만 추출
user.action.f <- user.action.h %>% select(matches('[A-Z]+[0-9]'))
# 어느 유저의 데이터인지 추적하기 위해 user.id를 row.names()로 설정
row.names(user.action.f) <- user.action.h$user_id
# user.action.f
# 정보량이 0에 가까운 변수를 삭제
nzv <- nearZeroVar(user.action.f)
user.action.f.filtered <- user.action.f[ , -nzv]
# user.action.f.filtered
# 변수간에 상관관계가 높은 것을 삭제
user.action.cor <- cor(user.action.f.filtered)
highly.cor.f <- findCorrelation(user.action.cor, cutoff = .7)
user.action.f.filtered_1 <- user.action.f.filtered[, -highly.cor.f]
user.action.f.filtered_1 %>% head()
user.action.f %>% dim
user.action.f.filtered_1 %>% dim
# 추후 K-Means 알고리즘을 위해 데이터가 정규화 되어 있는 것이 좋습니다. 그래서 scale = T 옵션을 추가합니다.
user.action.pca.base <- prcomp(user.action.f.filtered_1, scale = T)
user.action.pca.base$rotation %>% head()
knitr::opts_chunk$set(echo = TRUE)
library(plyr)
library(tidyverse)
library(data.table)
library(purrr)
library(caret)
library(ykmeans)
library(scales)
library(fmsb)
readInstall <- function(game_name, target_day) {
base_path <- './data/sample-data/section9/snapshot/install'
game_name <- game_name %>% as.character() # game-01...
target_day <- target_day %>% as.character()
file_name <- 'install.csv'
whole_path <- paste0(base_path, '/', game_name, '/', target_day, '/', file_name)
data <- whole_path %>% fread()
return(data)
}
readDauDates <- function(game_name, date.from, date.to) {
base_path <- './data/sample-data/section9/daily'
data_type <- 'dau'
game_name <- game_name %>% as.character() # game-01...
date.from <- date.from  %>% as.Date()
date.to <- date.to %>% as.Date()
dates <- seq.Date(date.from, date.to, by = 'day')
file_name <- 'dau.csv' # always dau.tsv...
whole_path <- paste0(base_path, '/', data_type, '/', game_name, '/', dates, '/', file_name)
data <- whole_path %>% map(~fread(.x)) %>% rbindlist()
return(data)
}
readActionDates <- function(game_name, action_name, date.from, date.to) {
base_path <- './data/sample-data/section9/daily/'
data_type <- 'action'
game_name <- game_name %>% as.character() # game-01...
action_name <- action_name %>% as.character()
date.from <- date.from  %>% as.Date()
date.to <- date.to %>% as.Date()
dates <- seq.Date(date.from, date.to, by = 'day')
file_name <- paste0(action_name, '.csv') # always dau.tsv...
whole_path <- paste0(base_path, '/', data_type, '/', game_name, '/',  action_name, '/', dates, '/', file_name)
data <- whole_path %>% map(~fread(.x)) %>% rbindlist()
return(data)
}
install <- readInstall('game-01', '2013-09-30')
head(install)
dau <- readDauDates('game-01', '2013-06-01', '2013-09-30')
head(dau)
battle <- readActionDates('game-01', 'battle', '2013-06-01', '2013-08-31')
battle %>% head()
message <- readActionDates('game-01', 'message', '2013-06-01', '2013-08-31')
message %>% head()
hlp <- readActionDates('game-01', 'help', '2013-06-01', '2013-08-31')
hlp %>% head()
dau %>%
inner_join(install, by = 'user_id', suffix = c("", ".inst")) -> dau.inst
dau.inst %>% head
dau.inst %>%
mutate(log_date = as.Date(log_date),
log_date.inst = as.Date(log_date.inst)) %>%
mutate(elapsed_days = as.numeric(log_date - log_date.inst)) %>%
filter(elapsed_days >= 7 & elapsed_days <= 13) -> dau.inst.7_13
dau.inst.7_13 %>% head
dau.inst.7_13 %>%
group_by(user_id) %>%
summarise(density = n()/7) -> dau.inst.7_13.login.ds
dau.inst.7_13.login.ds %>% head()
install %>%
filter(log_date >= '2013-06-01' & log_date <= '2013-08-23') -> target.install
target.install %>% head
target.install %>%
left_join(dau.inst.7_13.login.ds, by = 'user_id') %>%
mutate(density = ifelse(is.na(density), 0, density)) -> target.install.login.ds
target.install.login.ds %>% head()
target.install.login.ds %>% arrange(desc(density)) %>% head
battle %>%
inner_join(install, by = 'user_id', suffix = c("", ".inst")) -> battle.inst
battle.inst %>% head
battle.inst %>%
mutate(log_date = as.Date(log_date),
log_date.inst = as.Date(log_date.inst)) %>%
mutate(elapsed_days = as.numeric(log_date - log_date.inst)) -> battle.inst.1
battle.inst.1 %>% head
battle.inst.1 %>%
filter(elapsed_days >= 0 & elapsed_days <= 6) -> battle.inst.2
battle.inst.2 %>% head
battle.inst.2 %>%
mutate(elapsed_days = paste0('d', as.character(elapsed_days))) %>%
select(user_id, count, elapsed_days) %>%
group_by(user_id, elapsed_days) %>%
summarise(sum.count = sum(count)) %>%
ungroup() %>%
spread(elapsed_days, sum.count) %>%
replace(is.na(.), 0) -> battle.inst.2_1
battle.inst.2_1 %>% head()
battle.inst.2_1 %>%
select(user_id) -> df.user_id
battle.inst.2_1 %>%
select(-user_id) %>%
mutate(total = rowSums(.)) %>%
mutate_if(is.numeric, list(~  round(./total, 2))) -> battle.inst.prop
df.user_id %>%
bind_cols(battle.inst.prop) -> battle.inst.prop_1
battle.inst.prop_1
battle.inst.2_1 %>%
select(-user_id) %>%
prcomp(scale = T) -> pr_battle.inst
pr_battle.inst$x %>% as_tibble() -> pr_battle.inst_1
df.user_id %>%
bind_cols(pr_battle.inst_1) -> pr_battle.inst_2
pr_battle.inst_2
message %>%
inner_join(install, by = 'user_id', suffix = c('', '.inst')) -> msg.inst
# 메세지 행동일과 이용시작일의 차이 즉 경과일수를 구합니다.
msg.inst %>%
mutate(log_date = as.Date(log_date),
log_date.inst = as.Date(log_date.inst)) %>%
mutate(elapsed_days = as.numeric(log_date - log_date.inst)) -> msg.inst.1
# 경과일수가 1주 이내인 것만 추출합니다.
msg.inst.1 %>%
filter(elapsed_days >= 0 & elapsed_days <= 6) -> msg.inst.2
# 경과일수별 메세지 행동횟수가 열에 오도록 데이터를 배치합니다.
msg.inst.2 %>%
mutate(elapsed_days = paste0('d', as.character(elapsed_days))) %>%
select(user_id, count, elapsed_days) %>%
group_by(user_id, elapsed_days) %>%
summarise(sum.count = sum(count)) %>%
ungroup() %>%
spread(elapsed_days, sum.count) %>%
replace(is.na(.), 0) -> msg.inst.2_1
msg.inst.2_1 %>% head
# 비율 데이터를 작성합니다.
msg.inst.2_1 %>%
select(user_id) -> df.user_id
msg.inst.2_1 %>%
select(-user_id) %>%
mutate(total = rowSums(.)) %>%
mutate_if(is.numeric, list(~round(./total, 2))) -> msg.inst.prop
df.user_id %>%
bind_cols(msg.inst.prop) -> msg.inst.prop_1
msg.inst.prop_1 %>% head
msg.inst.2_1 %>%
select(-user_id) %>%
prcomp(scale = T) -> pr_msg.inst
pr_msg.inst$x %>% as_tibble() -> pr_msg.inst_1
df.user_id %>%
bind_cols(pr_msg.inst_1) -> pr_msg.inst_2
pr_msg.inst_2 %>% head
hlp %>%
inner_join(install, by = 'user_id', suffix = c('', '.inst')) -> hlp.inst
# 메세지 행동일과 이용시작일의 차이 즉 경과일수를 구합니다.
hlp.inst %>%
mutate(log_date = as.Date(log_date),
log_date.inst = as.Date(log_date.inst)) %>%
mutate(elapsed_days = as.numeric(log_date - log_date.inst)) -> hlp.inst.1
# 경과일수가 1주 이내인 것만 추출합니다.
hlp.inst.1 %>%
filter(elapsed_days >= 0 & elapsed_days <= 6) -> hlp.inst.2
# 경과일수별 메세지 행동횟수가 열에 오도록 데이터를 배치합니다.
hlp.inst.2 %>%
mutate(elapsed_days = paste0('d', as.character(elapsed_days))) %>%
select(user_id, count, elapsed_days) %>%
group_by(user_id, elapsed_days) %>%
summarise(sum.count = sum(count)) %>%
ungroup() %>%
spread(elapsed_days, sum.count) %>%
replace(is.na(.), 0) -> hlp.inst.2_1
hlp.inst.2_1 %>% head
# 비율 데이터를 작성합니다.
hlp.inst.2_1 %>%
select(user_id) -> df.user_id
hlp.inst.2_1 %>%
select(-user_id) %>%
mutate(total = rowSums(.)) %>%
mutate_if(is.numeric, list(~round(./total, 2))) -> hlp.inst.prop
df.user_id %>%
bind_cols(hlp.inst.prop) -> hlp.inst.prop_1
hlp.inst.prop_1 %>% head
hlp.inst.2_1 %>%
select(-user_id) %>%
prcomp(scale = T) -> pr_hlp.inst
pr_hlp.inst$x %>% as_tibble() -> pr_hlp.inst_1
df.user_id %>%
bind_cols(pr_hlp.inst_1) -> pr_hlp.inst_2
pr_hlp.inst_2 %>% head
library(foreach)
# 클러스터 데이터 작성 함수
createClusterData <- function(aname, x, x.prop, x.pca) {
set.seed(2019)
df <- ldply(foreach(i = 3:6, combine = rbind) %do% {
km <- kmeans(x[, -1], i)
km.prop <- kmeans(x.prop[, -1], i)
km.pca <- kmeans(x.pca[, -1], i)
data.frame(user_id = x$user_id,
cluster.type = sprintf('%s%02d', aname, i),
freq.cluster.id = km$cluster,
prop.cluster.id = km.prop$cluster,
pca.cluster.id = km.pca$cluster
)
})
cluster.melt <- melt(df, id.vars = c('user_id', 'cluster.type'))
dcast(cluster.melt, user_id ~ cluster.type + variable)
}
battle.cluster <- createClusterData('battle', battle.inst.2_1, battle.inst.prop_1, pr_battle.inst_2)
battle.cluster %>% head
msg.cluster <- createClusterData('msg', msg.inst.2_1, msg.inst.prop_1, pr_msg.inst_2)
msg.cluster %>% head
hlp.cluster <- createClusterData('hlp', hlp.inst.2_1, hlp.inst.prop_1, pr_hlp.inst_2)
hlp.cluster %>% head
target.install.login.ds %>%
left_join(battle.cluster, by = 'user_id') %>%
left_join(msg.cluster, by = 'user_id') %>%
left_join(hlp.cluster, by = 'user_id') %>%
replace(is.na(.), 0) -> cluster.data
cluster.data %>% head
cluster.data %>% head
cluster.data %>%
dplyr::select(-log_date, -install_time, -gender, -generation, -device_type) %>%
gather(variable, value, -user_id, -density) -> cluster.data.gathered
cluster.data.gathered %>% head
cluster.data.gathered %>%
group_by(variable, value) %>%
summarise(avg.density = mean(density)) -> cluster.data.avg
cluster.data.avg %>% head()
# 새로운 클러스터 번호  부여
cluster.data.avg %>%
arrange(variable, avg.density) %>%
group_by(variable) %>%
mutate(value2 = sort(value)) -> cluster.data.avg_1
cluster.data.avg_1 %>% head()
cluster.data.gathered %>%
inner_join(cluster.data.avg_1, by = c('variable', 'value')) -> cluster.data.gathered_1
cluster.data.gathered_1 %>%
select(user_id, density, variable, value2) %>%
spread(variable, value2) -> cluster.data_1
cluster.data_1 %>% head()
library(rpart)
fit <- rpart(density ~ ., cluster.data_1[, -1])
print(fit)
library(rpart.plot)
rpart.plot(fit)
cluster.data.gathered_1 %>%
filter(variable == 'hlp04_pca.cluster.id') %>%
select(user_id, avg.density, value2) %>%
rename(cluster = value2) -> cluster.data_2
cluster.data_2 %>% head
hlp.inst.prop_1 %>%
inner_join(cluster.data_2, by = 'user_id') %>%
count(cluster)
library(rpart)
fit <- rpart(density ~ ., cluster.data_1[, -1])
print(fit)
cluster.data %>%
dplyr::select(-log_date, -install_time, -gender, -generation, -device_type) %>%
gather(variable, value, -user_id, -density) -> cluster.data.gathered
cluster.data.gathered %>% head
df_1 <- data.frame(start = c(60000, 34000000),
end = c(3300000, 67980000809))
df_1
df_2 <- data.frame(start = c(4000, 100000, 70000, 34000001),
end = c(200000, 599099, 900020, 460000000))
source('~/.active-rstudio-document', echo=TRUE)
df_2 %>%
rename(start_1 = start,
end_1  = end)
df_2 %>%
rename(start_1 = start,
end_1  = end) -> df)2
df_2 %>%
rename(start_1 = start,
end_1  = end) -> ddf_2
df_1 %>%
bind_cols(df_1)
df_1 %>%
bind_rows(df_1)
df_2 %>%
rename(start_1 = start,
end_1  = end) -> df_2_1
df_1 %>%
bind_rows(df_1)  %>%
bind_cols(df_2_1)
start <= start_1 & end >= end_1, "O", "X")
df_1 %>%
df_1 %>%
df_1 %>%
bind_rows(df_1)  %>%
bind_cols(df_2_1) %>%
mutate(is_in_range = case_when(
start <= start_1 & end >= end_1, "O", "X"))
df_1 %>%
bind_rows(df_1)  %>%
bind_cols(df_2_1) %>%
mutate(is_in_range = case_when(
(start <= start_1 & end >= end_1), "O", "X"))
df_1 %>%
bind_rows(df_1)  %>%
bind_cols(df_2_1) %>%
mutate(is_in_range = case_when(
(start <= start_1 & end >= end_1) ~ "O"
TRUE ~ "X"))
df_1 %>%
bind_rows(df_1)  %>%
bind_cols(df_2_1) %>%
mutate(is_in_range = case_when(
(start <= start_1 & end >= end_1) ~ "O",
TRUE ~ "X"))
df_1 %>%
bind_rows(df_1)  %>%
bind_cols(df_2_1) %>%
mutate(is_in_range = case_when(
start <= start_1 & end >= end_1 ~ "O",
TRUE ~ "X"))
library(tidyverse)
df_1 <- data.frame(start = c(60000, 34000000),
end = c(3300000, 67980000809))
df_2 <- data.frame(start = c(4000, 100000, 70000, 34000001),
end = c(200000, 599099, 900020, 460000000))
# 이름의 중복을 피하기 위해 변수병을 변환("_1"을 붙여봄)
df_2 %>%
rename(start_1 = start,
end_1  = end) -> df_2_1
# 각 행마다 해당하는 조건을 대응시키기 위해 두 데이터 프레임의 행의 수를 같게 함.
df_1 %>%
bind_rows(df_1) -> df_1_1
df_1_1 %>%
bind_cols(df_2_1) %>%
mutate(is_in_range = case_when(
start <= start_1 & end >= end_1 ~ "O",
TRUE ~ "X"))
setwd("~/first_blogdown")
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", message=F, warning=F, cache = T)
library(ez)
library(ggplot2)
library(nlme)
library(pastecs)
library(reshape2)
library(WRS)
library(clinfun)
library(pgirmess)
library(car)
library(tidyverse)
# install.packages('mvoutlier')
library(mvoutlier)
library(gmodels)
library(MASS)
library(nlme) # 다층모형을 위해
library(QuantPsyc)
library(boot)
# install.packages('epiDisplay')
library(epiDisplay)
library(knitr)
# install.packages('mlogit')
library(mlogit)
library(plotly)
library(curl)
library(gridExtra)
library(GGally)
library(caret)
library(DT)
library(ROCR)
adult <- read_csv('https://raw.githubusercontent.com/jakinpilla/first_blogdown/master/public/post/data/adult_1.csv')
# adult <- read_csv('./data/adult_1.csv')
adult %>% glimpse()
model.matrix(~ . -wage, adult ) %>%
as_tibble() -> df_1
adult %>%
select(wage) %>%
bind_cols(df_1) %>%
select(-`(Intercept)`) -> adult_mm
adult_mm %>%
count(wage) %>%
ggplot(aes(wage, n, fill = wage)) + geom_bar(stat = 'identity') +
scale_fill_manual(values = c('steelblue', 'red'), aesthetics = 'fill') +
theme_minimal()
set.seed(2020)
df <- adult_mm
train_idx <- createDataPartition(df$wage, p = .6, list = F)[, 1]
resid_idx <- setdiff(1:nrow(df), train_idx)
resid_df <- df[resid_idx, ]
# length(train_idx)
# length(resid_idx)
val_idx <- createDataPartition(resid_df$wage, p = .5, list = F)[, 1]
# length(val_idx)
test_idx <- setdiff(1:nrow(resid_df), val_idx)
# length(test_idx)
train_data <- df[train_idx, ]
# dim(train_data)
val_data <- resid_df[val_idx, ]
# dim(val_data)
test_data <- resid_df[test_idx, ]
# dim(test_data)
train_data %>%
count(wage) %>%
ggplot(aes(wage, n, fill = wage)) + geom_bar(stat = 'identity') +
scale_fill_manual(values = c('steelblue', 'red'), aesthetics = 'fill') +
theme_minimal()
train_data %>% dim()
val_data %>%
count(wage) %>%
ggplot(aes(wage, n, fill = wage)) + geom_bar(stat = 'identity') +
scale_fill_manual(values = c('steelblue', 'red'), aesthetics = 'fill') +
theme_minimal()
test_data %>%
count(wage) %>%
ggplot(aes(wage, n, fill = wage)) + geom_bar(stat = 'identity') +
scale_fill_manual(values = c('steelblue', 'red'), aesthetics = 'fill') +
theme_minimal()
test_data %>% dim()
train_data %>%
mutate(wage = ifelse(wage == "<=50K", 0, 1)) -> train_data_1
df <- train_data_1 %>% head(100)
DT::datatable(df,
options = list(
scrollX = TRUE,
scrollCollapse = TRUE
))
adult_logistic_m <- glm(wage ~ ., data = train_data_1, family = binomial)
# summary(adult_logistic_m)
y_obs <- ifelse(val_data$wage == "<=50K", 0, 1)
# val_data를 predict() 함수에 넣기 전에 다음과 같은 전처리가 필요합니다. wage 변수를 예측하려는데
# wage 변수가 들어가 있는 데이터를 사용하면 안 되기 때문입니다.
val_data %>%
select(-wage) -> val_data_1
yhat_logistic <- predict(adult_logistic_m, newdata = val_data_1, type = 'response')
pred_logistic <- prediction(yhat_logistic, y_obs)
perf_logistic <- performance(pred_logistic, measure = "tpr", x.measure = "fpr")
df_logistic <- data.frame(FPR = perf_logistic@x.values[[1]], TPR = perf_logistic@y.values[[1]]) %>%
as_tibble()
df_logistic %>% ggplot(aes(x = FPR, y = TPR)) +
geom_line(color = 'blue') +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1)) +
ggtitle('ROC Curve') +
labs(x = 'False Positive Rate', y = 'True Positive Rate') +
theme_minimal() -> p; p
performance(pred_logistic, "auc")@y.values[[1]]
blogdown:::serve_site()
df_logistic <- data.frame(FPR = perf_logistic@x.values[[1]], TPR = perf_logistic@y.values[[1]]) %>%
as_tibble()
df_logistic %>% ggplot(aes(x = FPR, y = TPR)) +
geom_line(color = 'blue') +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1)) +
ggtitle('ROC Curve') +
labs(x = 'False Positive Rate', y = 'True Positive Rate') +
theme_minimal() -> p; ggplotly(p)
df_logistic <- data.frame(FPR = perf_logistic@x.values[[1]], TPR = perf_logistic@y.values[[1]]) %>%
as_tibble()
df_logistic %>% ggplot(aes(x = FPR, y = TPR)) +
geom_line(color = 'blue') +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1)) +
ggtitle('ROC Curve') +
labs(x = 'False Positive Rate', y = 'True Positive Rate') +
theme_minimal() -> p; p

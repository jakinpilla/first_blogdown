---
title: "Support Vector Machine: Theory"
author: "Daniel Kim"
date: "2020-05-08"
output: 
    html_document:
      toc : true
      toc_depth : 5
---



<pre class="r"><code>library(e1071)
library(tidyverse)
library(plotly)</code></pre>
<p>Logistic Regression에서는 확률을 이용합니다. 바로 확률을 이용해서 Decision Boundary를 결정합니다. 그런데 Support Vector Machine은 확률을 이용하지 않습니다. 다른 방법으로 Decision Boudary를 설정합니다.</p>
<pre class="r"><code># create linear_plot_with_theta_delta() funcition
# theata means a slope and delta means a margin

# set seed
set.seed(2020)
n &lt;- 50  
df &lt;- data.frame(x1 = runif(n), x2 = runif(n))
  

linear_plot_with_theta_delta &lt;- function(theta, delta) {
  

  # Generate data frame with two uniformly distributed predictors lying between 0 and 1.
  # classify data points depending on location
  df$y &lt;- factor(ifelse(df$x2 - theta*df$x1 &lt; 0, 0, 1), 
                 levels = c(0, 1))
  
  # retain only those points that lie outside the margin
  df_1 &lt;- df[abs(theta*df$x1 - df$x2) &gt; delta, ]
  
  # build plot
  plot_theta_margins &lt;- ggplot(data = df_1, aes(x = x1, y = x2, color = y)) + geom_point() + 
    scale_color_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + 
    geom_abline(slope = theta, intercept = 0, color = &quot;green&quot;, size = 1.2)+
    geom_abline(slope = theta, intercept = delta, linetype = &quot;dashed&quot;) +
    geom_abline(slope = theta, intercept = -delta, linetype = &quot;dashed&quot;) +
    theme(legend.position = &quot;none&quot;)
    # ggtitle(paste0(&quot;slope=&quot;, as.character(theta), &quot; delta=&quot;, as.character(delta)))
  
  #&#39; display plot
  plot_theta_margins
  
}

linear_plot_with_theta_delta(1, .1) +
  theme_minimal()</code></pre>
<p><img src="/post/2020-05-07-Support_Vector_Machine_files/figure-html/unnamed-chunk-2-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>linear_plot_with_theta_delta(1, .1) +
  geom_abline(intercept = -.1, slope = 1.2, color = &#39;blue&#39;, size = 1.2) +
  geom_abline(intercept = .1, slope = .8, color = &#39;red&#39;, size = 1.2) +
  theme_minimal()</code></pre>
<p><img src="/post/2020-05-07-Support_Vector_Machine_files/figure-html/unnamed-chunk-3-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>위의 그림에서 파란 점은 목적변수가 Positive 즉 1인 경우이고 빨간 점은 반대로 목적변수가 Negative 즉 0인 겨우입니다. 2차원에서 데이터를 정확히 2개의 그룹으로 분류하는 선 즉 Decision Boudary들은 여러 경우가 있을 수 있습니다. 그 중 저는 3가지 경우, 즉 파란선, 빨간선 드리고 초록선을 그려보았습니다. 이 셋 모델 모두 데이터를 정확히 Positive와 Negative로 100퍼센트 분리합니다.</p>
<p>그련데 우리의 직관은 뭔가 자꾸만 초록색 선이 다른 두 개의 선보다 더 훌륭한 Decision Boudary라고 하는 것 같습니다. 왠지 그렇지 않나요? 먼저 빨간색 Decision Boundary만 놓고 생각해 볼까요?</p>
<pre class="r"><code>df$y &lt;- factor(ifelse(df$x2 - 1*df$x1 &lt; 0, 0, 1), 
                 levels = c(0, 1))
df_1 &lt;- df[abs(1*df$x1 - df$x2) &gt; .1, ]

df_1 %&gt;%
  filter(y == 0) %&gt;%
  filter(x1 &gt; .75) %&gt;%
  filter(x2 &gt; .625 &amp; x2 &lt; .875) -&gt; df_tmp_1

df_1 %&gt;%
  filter(y == 1) %&gt;%
  filter(x1 &lt; .25) %&gt;%
  filter(x2 &gt; .1 &amp; x2 &lt; .375) -&gt; df_tmp_2


df_tmp_1 %&gt;%
  bind_rows(df_tmp_2) -&gt; df_2

linear_plot_with_theta_delta(1, .1) +
  geom_abline(intercept = .1, slope = .8, color = &#39;red&#39;, size = 1.2) +
  geom_point(data = df_2, aes(x1, x2), size = 7, alpha = .5, color = &#39;purple&#39;) +
  theme_minimal() -&gt; p; p</code></pre>
<p><img src="/post/2020-05-07-Support_Vector_Machine_files/figure-html/unnamed-chunk-4-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>빨간선의 경우 그림에서처럼 4개의 보라색 원으로 감싸여진 데이터가 매우 Decision Boundary와 가까워집니다. 데이터라는 것은 언제나 특정 시점의 관측자에 의해 측정되어진 것이기에 그 값은 측정 시점과 관측자의 상태에 따라 변동이 생깁니다. 만약 위의 보라색 원 안에 있는 데이터들이 상하좌우로 이동을 하게 된다면 어떨까요? 어떤 경우는 Decision Boundary를 넘어가 Positive를 Negative로 혹은 Negative를 Positive로 잘못 분류하는 경우가 발생합니다. 즉, 빨간선을 Decision Boundary로 가지는 분류모델은 초록선을 Decision Boundary로 가지는 분류모델에 비해 불안한 나쁜 모델이라고 할 수 있습니다. 즉 우리의 직관이 맞는 겁니다.</p>
<p>그런데 어떻게 이 초록색 Decision Boundary를 잘 찾을 수 있을까요? 어떻게 이 Decision Boundary를 계산할 수 있을까요?</p>
<p>여기서 잠깐 한 직선과 여러 점들사이의 거리를 계산하는 문제를 생각해보겠습니다.</p>
<pre class="r"><code># the line&#39;s slope and intercept information
slope &lt;- .8
intercept &lt;- .1

perp.segment.coord &lt;- function(x1, x2, intercept, slope){
  # finds endpoint for a perpendicular segment from the point (x1,x2) to the line
  # defined by ortho as y = a*x + b
  a &lt;- slope  # slope
  b &lt;- intercept  # intercept
  xp1 &lt;- (x1 + a*x2 - a*b)/(1 + a^2)
  xp2 &lt;- b + a*xp1
  list(x1=x1, x2=x2, xp1=xp1, xp2=xp2)
}

perp.segment &lt;- perp.segment.coord(df_1$x1, df_1$x2, intercept, slope)
perp.segment_1 &lt;- perp.segment %&gt;% as.data.frame()
perp.segment_1 %&gt;%
  mutate(y = df_1$y) -&gt; perp.segment_2

ggplot(data = df_1, aes(x1, x2, color = y)) +
  geom_point() +
  scale_color_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + 
  xlim(0, 1) +
  ylim(0, 1) +
  geom_abline(intercept = intercept, slope = slope) +
  geom_segment(data = perp.segment_2,
               aes(x = x1, y= x2, xend = xp1, yend = xp2), 
               lty = &#39;dashed&#39;) +
  theme_minimal()</code></pre>
<p><img src="/post/2020-05-07-Support_Vector_Machine_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>netlify deploy가 불안정합니다.</p>
